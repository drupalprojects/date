<?php

/**
 * @file
 * This module will make the date API available to other modules.
 * Designed to provide a light but flexible assortment of functions
 * and constants, with more functionality in additional files that
 * are not loaded unless other modules specifically include them.
 */

use Drupal\Core\Datetime\DrupalDate;
use Drupal\date_api\DateHelper;

/**
 * Set up some constants.
 *
 * Includes standard date types, format strings, strict regex strings for ISO
 * and DATETIME formats (seconds are optional).
 *
 * The loose regex will find any variety of ISO date and time, with or
 * without time, with or without dashes and colons separating the elements,
 * and with either a 'T' or a space separating date and time.
 */
const DATE_ISO = 'date';
const DATE_UNIX = 'datestamp';
const DATE_DATETIME = 'datetime';
const DATE_ARRAY = 'array';
const DATE_OBJECT = 'object';
const DATE_ICAL = 'ical';

const DATE_FORMAT_ISO = "Y-m-d\TH:i:s";
const DATE_FORMAT_UNIX = "U";
const DATE_FORMAT_DATETIME = "Y-m-d H:i:s";
const DATE_FORMAT_ICAL = "Ymd\THis";
const DATE_FORMAT_ICAL_DATE = "Ymd";
const DATE_FORMAT_DATE = 'Y-m-d';

/**
 * Core DateTime extension module used for as many date operations as possible.
 */

/**
 * Implements hook_help().
 */
function date_help($path, $arg) {
  switch ($path) {
    case 'admin/help#date':
      $output = '';
      if (module_exists('date_tools')) {
        $output .= '<h3>Date Tools</h3>' . t('Dates and calendars can be complicated to set up. The !date_wizard makes it easy to create a simple date content type and with a date field. ', array('!date_wizard' => l(t('Date wizard'), 'admin/config/date/tools/date_wizard')));
      }
      else {
        $output .= '<h3>Date Tools</h3>' . t('Dates and calendars can be complicated to set up. If you enable the Date Tools module, it provides a Date Wizard that makes it easy to create a simple date content type with a date field. ');
      }

      $output .= '<h2>More Information</h2><p>' . t('Complete documentation for the Date and Date API modules is available at <a href="@link">http://drupal.org/node/92460</a>.', array('@link' => 'http://drupal.org/node/262062')) . '</p>';

      return $output;
      break;
  }
}

/**
 * Implements hook_menu().
 *
 * Creates a 'Date API' section on the administration page for Date
 * modules to use for their configuration and settings.
 */
function date_api_menu() {
  $items['admin/config/date'] = array(
    'title' => 'Date API',
    'description' => 'Settings for modules the use the Date API.',
    'position' => 'left',
    'weight' => -10,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer site configuration'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  return $items;
}

/**
 * Determines if the date element needs to be processed.
 *
 * Helper function to see if date element has been hidden by FAPI to see if it
 * needs to be processed or just pass the value through. This is needed since
 * normal date processing explands the date element into parts and then
 * reconstructs it, which is not needed or desirable if the field is hidden.
 *
 * @param array $element
 *   The date element to check.
 *
 * @return bool
 *   TRUE if the element is effectively hidden, FALSE otherwise.
 */
function date_hidden_element($element) {
  // @TODO What else needs to be tested to see if dates are hidden or disabled?
  if ((isset($element['#access']) && empty($element['#access']))
    || !empty($element['#programmed'])
    || in_array($element['#type'], array('hidden', 'value'))) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function for getting the format string for a date type.
 *
 * @param string $type
 *   A date type format name.
 *
 * @return string
 *   A date type format, like 'Y-m-d H:i:s'.
 */
function date_type_format($type) {
  switch ($type) {
    case DATE_ISO:
      return DATE_FORMAT_ISO;
    case DATE_UNIX:
      return DATE_FORMAT_UNIX;
    case DATE_DATETIME:
      return DATE_FORMAT_DATETIME;
    case DATE_ICAL:
      return DATE_FORMAT_ICAL;
  }
}

/**
 * Constructs an array of regex replacement strings for date format elements.
 *
 * @param bool $strict
 *   Whether or not to force 2 digits for elements that sometimes allow either
 *   1 or 2 digits.
 *
 * @return array
 *   An array of date() format letters and their regex equivalents.
 */
function date_format_patterns($strict = FALSE) {
  return array(
    'd' => '\d{' . ($strict ? '2' : '1,2') . '}',
    'm' => '\d{' . ($strict ? '2' : '1,2') . '}',
    'h' => '\d{' . ($strict ? '2' : '1,2') . '}',
    'H' => '\d{' . ($strict ? '2' : '1,2') . '}',
    'i' => '\d{' . ($strict ? '2' : '1,2') . '}',
    's' => '\d{' . ($strict ? '2' : '1,2') . '}',
    'j' => '\d{1,2}',
    'N' => '\d',
    'S' => '\w{2}',
    'w' => '\d',
    'z' => '\d{1,3}',
    'W' => '\d{1,2}',
    'n' => '\d{1,2}',
    't' => '\d{2}',
    'L' => '\d',
    'o' => '\d{4}',
    'Y' => '-?\d{1,6}',
    'y' => '\d{2}',
    'B' => '\d{3}',
    'g' => '\d{1,2}',
    'G' => '\d{1,2}',
    'e' => '\w*',
    'I' => '\d',
    'T' => '\w*',
    'U' => '\d*',
    'z' => '[+-]?\d*',
    'O' => '[+-]?\d{4}',
    // Using S instead of w and 3 as well as 4 to pick up non-ASCII chars like
    // German umlaut. Per http://drupal.org/node/1101284, we may need as little
    // as 2 and as many as 5 characters in some languages.
    'D' => '\S{2,5}',
    'l' => '\S*',
    'M' => '\S{2,5}',
    'F' => '\S*',
    'P' => '[+-]?\d{2}\:\d{2}',
    'O' => '[+-]\d{4}',
    'c' => '(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})([+-]?\d{2}\:\d{2})',
    'r' => '(\w{3}), (\d{2})\s(\w{3})\s(\d{2,4})\s(\d{2}):(\d{2}):(\d{2})([+-]?\d{4})?',
  );
}

/**
 * Constructs an array of granularity options and their labels.
 *
 * @return array
 *   An array of translated date parts, keyed by their machine name.
 */
function date_granularity_names() {
  return array(
    'year' => t('Year', array(), array('context' => 'datetime')),
    'month' => t('Month', array(), array('context' => 'datetime')),
    'day' => t('Day', array(), array('context' => 'datetime')),
    'hour' => t('Hour', array(), array('context' => 'datetime')),
    'minute' => t('Minute', array(), array('context' => 'datetime')),
    'second' => t('Second', array(), array('context' => 'datetime')),
  );
}

/**
 * Returns an array of system-allowed timezone abbreviations.
 *
 * Cache an array of just the abbreviation names because the whole
 * timezone_abbreviations_list() is huge, so we don't want to retrieve it more
 * than necessary.
 *
 * @param bool $refresh
 *   (optional) Whether to refresh the list. Defaults to TRUE.
 *
 * @return array
 *   An array of allowed timezone abbreviations.
 */
function date_timezone_abbr($refresh = FALSE) {
  $cached = cache_get('date_timezone_abbreviations');
  $data = isset($cached->data) ? $cached->data : array();
  if (empty($data) || $refresh) {
    $data = array_keys(timezone_abbreviations_list());
    cache_set('date_timezone_abbreviations', $data);
  }
  return $data;
}

/**
 * Formats a date, using a date type or a custom date format string.
 *
 * Reworked from Drupal's format_date function to handle pre-1970 and
 * post-2038 dates and accept a date object instead of a timestamp as input.
 * Translates formatted date results, unlike PHP function date_format().
 * Should only be used for display, not input, because it can't be parsed.
 *
 * @param object $date
 *   A date object.
 * @param string $type
 *   (optional) The date format to use. Can be 'small', 'medium' or 'large' for
 *   the preconfigured date formats. If 'custom' is specified, then $format is
 *   required as well. Defaults to 'medium'.
 * @param string $format
 *   (optional) A PHP date format string as required by date(). A backslash
 *   should be used before a character to avoid interpreting the character as
 *   part of a date format. Defaults to an empty string.
 * @param string $langcode
 *   (optional) Language code to translate to. Defaults to NULL.
 *
 * @return string
 *   A translated date string in the requested format.
 *
 * @see format_date()
 */
function date_format_date($date, $type = 'medium', $format = '', $langcode = NULL) {
  if (empty($date)) {
    return '';
  }
  if ($type != 'custom') {
    $format = variable_get('date_format_' . $type);
  }
  if ($type != 'custom' && empty($format)) {
    $format = variable_get('date_format_medium', 'D, m/d/Y - H:i');
  }
  $max = strlen($format);
  $datestring = '';
  for ($i = 0; $i < $max; $i++) {
    $c = $format[$i];
    switch ($c) {
      case 'l':
        $datestring .= t($date->format('l'), array(), array('context' => '', 'langcode' => $langcode));
        break;
      case 'D':
        $datestring .= t($date->format('D'), array(), array('context' => '', 'langcode' => $langcode));
        break;
      case 'F':
        $datestring .= t($date->format('F'), array(), array('context' => 'Long month name', 'langcode' => $langcode));
        break;
      case 'M':
        $datestring .= t($date->format('M'), array(), array('langcode' => $langcode));
        break;
      case 'A':
      case 'a':
        $datestring .= t($date->format($c), array(), array('context' => 'ampm', 'langcode' => $langcode));
        break;
      // The timezone name translations can use t().
      case 'e':
      case 'T':
        $datestring .= t($date->format($c));
        break;
      // Remaining date parts need no translation.
      case 'O':
        $datestring .= sprintf('%s%02d%02d', (date_offset_get($date) < 0 ? '-' : '+'), abs(date_offset_get($date) / 3600), abs(date_offset_get($date) % 3600) / 60);
        break;
      case 'P':
        $datestring .= sprintf('%s%02d:%02d', (date_offset_get($date) < 0 ? '-' : '+'), abs(date_offset_get($date) / 3600), abs(date_offset_get($date) % 3600) / 60);
        break;
      case 'Z':
        $datestring .= date_offset_get($date);
        break;
      case '\\':
        $datestring .= $format[++$i];
        break;
      case 'r':
        $datestring .= date_format_date($date, 'custom', 'D, d M Y H:i:s O', $langcode);
        break;
      default:
        if (strpos('BdcgGhHiIjLmnNosStTuUwWYyz', $c) !== FALSE) {
          $datestring .= $date->format($c);
        }
        else {
          $datestring .= $c;
        }
    }
  }
  return $datestring;
}

/**
 * Formats a time interval with granularity, including past and future context.
 *
 * @param object $date
 *   The current date object.
 * @param int $granularity
 *   (optional) Number of units to display in the string. Defaults to 2.
 *
 * @return string
 *   A translated string representation of the interval.
 *
 * @see format_interval()
 */
function date_format_interval($date, $granularity = 2, $display_ago = TRUE) {
  // If no date is sent, then return nothing.
  if (empty($date)) {
    return NULL;
  }

  $interval = REQUEST_TIME - $date->format('U');
  if ($interval > 0) {
    return $display_ago ? t('!time ago', array('!time' => format_interval($interval, $granularity))) :
      t('!time', array('!time' => format_interval($interval, $granularity)));
  }
  else {
    return format_interval(abs($interval), $granularity);
  }
}

/**
 * Determines if a timezone string is valid.
 *
 * @param string $timezone
 *   A potentially invalid timezone string.
 *
 * @return bool
 *   TRUE if the timezone is valid, FALSE otherwise.
 */
function date_timezone_is_valid($timezone) {
  static $timezone_names;
  if (empty($timezone_names)) {
    $timezone_names = array_keys(system_time_zones(TRUE));
  }
  return in_array($timezone, $timezone_names);
}

/**
 * Returns a timezone name to use as a default.
 *
 * @param bool $check_user
 *   (optional) Whether or not to check for a user-configured timezone.
 *   Defaults to TRUE.
 *
 * @return string
 *   The default timezone for a user, if available, otherwise the site.
 */
function date_default_timezone($check_user = TRUE) {
  global $user;
  if ($check_user && variable_get('configurable_timezones', 1) && !empty($user->timezone)) {
    return $user->timezone;
  }
  else {
    $default = variable_get('date_default_timezone', '');
    return empty($default) ? 'UTC' : $default;
  }
}

/**
 * Returns a timezone object for the default timezone.
 *
 * @param bool $check_user
 *   (optional) Whether or not to check for a user-configured timezone.
 *   Defaults to TRUE.
 *
 * @return object
 *   The default timezone for a user, if available, otherwise the site.
 */
function date_default_timezone_object($check_user = TRUE) {
  return timezone_open(date_default_timezone($check_user));
}


/**
 * Implements hook_element_info().
 */
function date_api_element_info() {
  module_load_include('inc', 'date_api', 'date_api_elements');
  return _date_api_element_info();
}

/**
 * Implements hook_theme().
 */
function date_api_theme($existing, $type, $theme, $path) {
  $base = array(
    'file' => 'theme.inc',
    'path' => "$path/theme",
  );
  return array(
    'date_nav_title' => $base + array('variables' => array('granularity' => NULL, 'view' => NULL, 'link' => NULL, 'format' => NULL)),
    'date_timezone' => $base + array('render element' => 'element'),
    'date_select' => $base + array('render element' => 'element'),
    'date_text' => $base + array('render element' => 'element'),
    'date_select_element' => $base + array('render element' => 'element'),
    'date_textfield_element' => $base + array('render element' => 'element'),
    'date_part_hour_prefix' => $base + array('render element' => 'element'),
    'date_part_minsec_prefix' => $base + array('render element' => 'element'),
    'date_part_label_year' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_month' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_day' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_hour' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_minute' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_second' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_ampm' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_timezone' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_date' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_part_label_time' => $base + array('variables' => array('date_part' => NULL, 'element' => NULL)),
    'date_views_filter_form' => $base + array('template' => 'date-views-filter-form', 'render element' => 'form'),
    'date_calendar_day' => $base + array('variables' => array('date' => NULL)),
    'date_time_ago' => $base + array('variables' => array('start_date' => NULL, 'end_date' => NULL, 'interval' => NULL)),
  );
}

/**
 * Function to figure out which local timezone applies to a date and select it.
 *
 * @param string $handling
 *   The timezone handling.
 * @param string $timezone
 *   (optional) A timezone string. Defaults to an empty string.
 *
 * @return string
 *   The timezone string.
 */
function date_get_timezone($handling, $timezone = '') {
  switch ($handling) {
    case 'date':
      $timezone = !empty($timezone) ? $timezone : date_default_timezone();
      break;
    case 'utc':
      $timezone = 'UTC';
      break;
    default:
      $timezone = date_default_timezone();
  }
  return $timezone > '' ? $timezone : date_default_timezone();
}

/**
 * Function to figure out which db timezone applies to a date and select it.
 *
 * @param string $handling
 *   The timezone handling.
 * @param string $timezone
 *   (optional) A timezone string. Defaults to an empty string.
 *
 * @return string
 *   The timezone string.
 */
function date_get_timezone_db($handling, $timezone = '') {
  switch ($handling) {
    case 'none':
      $timezone = date_default_timezone();
      break;
    default:
      $timezone = 'UTC';
      break;
  }
  return $timezone > '' ? $timezone : 'UTC';
}

/**
 * Helper function for converting back and forth from '+1' to 'First'.
 */
function date_order_translated() {
  return array(
    '+1' => t('First', array(), array('context' => 'date_order')),
    '+2' => t('Second', array(), array('context' => 'date_order')),
    '+3' => t('Third', array(), array('context' => 'date_order')),
    '+4' => t('Fourth', array(), array('context' => 'date_order')),
    '+5' => t('Fifth', array(), array('context' => 'date_order')),
    '-1' => t('Last', array(), array('context' => 'date_order_reverse')),
    '-2' => t('Next to last', array(), array('context' => 'date_order_reverse')),
    '-3' => t('Third from last', array(), array('context' => 'date_order_reverse')),
    '-4' => t('Fourth from last', array(), array('context' => 'date_order_reverse')),
    '-5' => t('Fifth from last', array(), array('context' => 'date_order_reverse')),
  );
}

/**
 * Creates an array of ordered strings, using English text when possible.
 */
function date_order() {
  return array(
    '+1' => 'First',
    '+2' => 'Second',
    '+3' => 'Third',
    '+4' => 'Fourth',
    '+5' => 'Fifth',
    '-1' => 'Last',
    '-2' => '-2',
    '-3' => '-3',
    '-4' => '-4',
    '-5' => '-5',
  );
}

/**
 * Tests validity of a date range string.
 *
 * @param string $string
 *   A min and max year string like '-3:+1'a.
 *
 * @return bool
 *   TRUE if the date range is valid, FALSE otherwise.
 */
function date_range_valid($string) {
  $matches = preg_match('@^(\-[0-9]+|[0-9]{4}):([\+|\-][0-9]+|[0-9]{4})$@', $string);
  return $matches < 1 ? FALSE : TRUE;
}

/**
 * Splits a string like -3:+3 or 2001:2010 into an array of min and max years.
 *
 * Center the range around the current year, if any, but expand it far
 * enough so it will pick up the year value in the field in case
 * the value in the field is outside the initial range.
 *
 * @param string $string
 *   A min and max year string like '-3:+1'.
 * @param object $date
 *   (optional) A date object. Defaults to NULL.
 *
 * @return array
 *   A numerically indexed array, containing a minimum and maximum year.
 */
function date_range_years($string, $date = NULL) {
  $this_year = date_format(new DrupalDate(), 'Y');
  list($min_year, $max_year) = explode(':', $string);

  // Valid patterns would be -5:+5, 0:+1, 2008:2010.
  $plus_pattern = '@[\+|\-][0-9]{1,4}@';
  $year_pattern = '@^[0-9]{4}@';
  if (!preg_match($year_pattern, $min_year, $matches)) {
    if (preg_match($plus_pattern, $min_year, $matches)) {
      $min_year = $this_year + $matches[0];
    }
    else {
      $min_year = $this_year;
    }
  }
  if (!preg_match($year_pattern, $max_year, $matches)) {
    if (preg_match($plus_pattern, $max_year, $matches)) {
      $max_year = $this_year + $matches[0];
    }
    else {
      $max_year = $this_year;
    }
  }
  // We expect the $min year to be less than the $max year.
  // Some custom values for -99:+99 might not obey that.
  if ($min_year > $max_year) {
    $temp = $max_year;
    $max_year = $min_year;
    $min_year = $temp;
  }
  // If there is a current value, stretch the range to include it.
  $value_year = is_object($date) ? $date->format('Y') : '';
  if (!empty($value_year)) {
    $min_year = min($value_year, $min_year);
    $max_year = max($value_year, $max_year);
  }
  return array($min_year, $max_year);
}

/**
 * Converts a min and max year into a string like '-3:+1'.
 *
 * @param array $years
 *   A numerically indexed array, containing a minimum and maximum year.
 *
 * @return string
 *   A min and max year string like '-3:+1'.
 */
function date_range_string($years) {
  $this_year = date_format(new DrupalDate(), 'Y');

  if ($years[0] < $this_year) {
    $min = '-' . ($this_year - $years[0]);
  }
  else {
    $min = '+' . ($years[0] - $this_year);
  }

  if ($years[1] < $this_year) {
    $max = '-' . ($this_year - $years[1]);
  }
  else {
    $max = '+' . ($years[1] - $this_year);
  }

  return $min . ':' . $max;
}

/**
 * Temporary helper to re-create equivalent of content_database_info().
 */
function date_api_database_info($field, $revision = FIELD_LOAD_CURRENT) {
  return array(
    'columns' => $field['storage']['details']['sql'][$revision],
    'table' => _field_sql_storage_tablename($field),
  );
}

/**
 * Implements hook_form_FORM_ID_alter() for system_regional_settings().
 *
 * Add a form element to configure whether or not week numbers are ISO-8601, the
 * default is FALSE (US/UK/AUS norm).
 */
function date_api_form_system_regional_settings_alter(&$form, &$form_state, $form_id) {
  $form['locale']['date_api_iso8601'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use ISO-8601 week numbers'),
    '#default_value' => config('date_api.settings')->get('iso8601'),
    '#description' => t('IMPORTANT! If checked, First day of week MUST be set to Monday'),
  );
  $form['#validate'][] = 'date_api_form_system_settings_validate';
  $form['#submit'][] = 'date_api_form_system_settings_submit';
}

/**
 * Validate that the option to use ISO weeks matches first day of week choice.
 */
function date_api_form_system_settings_validate(&$form, &$form_state) {
  $form_values = $form_state['values'];
  if ($form_values['date_api_iso8601'] && $form_values['date_first_day'] != 1) {
    form_set_error('date_first_day', t('When using ISO-8601 week numbers, the first day of the week must be set to Monday.'));
  }
}

/**
 * Store the Date API 8601 week numbers setting.
 */
function date_api_form_system_settings_submit($form, &$form_state) {
  $form_values = $form_state['values'];
  config('date_api.settings')->set('iso8601', $form_values['date_api_iso8601'])->save();
}

/**
 * Creates an array of date format types for use as an options list.
 */
function date_format_type_options() {
  $options = array();
  $format_types = system_get_date_types();
  if (!empty($format_types)) {
    foreach ($format_types as $type => $type_info) {
      $options[$type] = $type_info['title'] . ' (' . date_format_date(date_example_date(), $type) . ')';
    }
  }
  return $options;
}

/**
 * Creates an example date.
 *
 * This ensures a clear difference between month and day, and 12 and 24 hours.
 */
function date_example_date() {
  $now = new DrupalDate();
  if (date_format($now, 'M') == date_format($now, 'F')) {
    date_modify($now, '+1 month');
  }
  if (date_format($now, 'm') == date_format($now, 'd')) {
    date_modify($now, '+1 day');
  }
  if (date_format($now, 'H') == date_format($now, 'h')) {
    date_modify($now, '+12 hours');
  }
  return $now;
}

/**
 * Determine if a start/end date combination qualify as 'All day'.
 *
 * @param string $string1
 *   A string date in datetime format for the 'start' date.
 * @param string $string2
 *   A string date in datetime format for the 'end' date.
 * @param string $granularity
 *   (optional) The granularity of the date. Defaults to 'second'.
 * @param int $increment
 *   (optional) The increment of the date. Defaults to 1.
 *
 * @return bool
 *   TRUE if the date is all day, FALSE otherwise.
 */
function date_is_all_day($string1, $string2, $granularity = 'second', $increment = 1) {
  if (empty($string1) || empty($string2)) {
    return FALSE;
  }
  elseif (!in_array($granularity, array('hour', 'minute', 'second'))) {
    return FALSE;
  }

  preg_match('/([0-9]{4}-[0-9]{2}-[0-9]{2}) (([0-9]{2}):([0-9]{2}):([0-9]{2}))/', $string1, $matches);
  $count = count($matches);
  $date1 = $count > 1 ? $matches[1] : '';
  $time1 = $count > 2 ? $matches[2] : '';
  $hour1 = $count > 3 ? intval($matches[3]) : 0;
  $min1 = $count > 4 ? intval($matches[4]) : 0;
  $sec1 = $count > 5 ? intval($matches[5]) : 0;
  preg_match('/([0-9]{4}-[0-9]{2}-[0-9]{2}) (([0-9]{2}):([0-9]{2}):([0-9]{2}))/', $string2, $matches);
  $count = count($matches);
  $date2 = $count > 1 ? $matches[1] : '';
  $time2 = $count > 2 ? $matches[2] : '';
  $hour2 = $count > 3 ? intval($matches[3]) : 0;
  $min2 = $count > 4 ? intval($matches[4]) : 0;
  $sec2 = $count > 5 ? intval($matches[5]) : 0;
  if (empty($date1) || empty($date2)) {
    return FALSE;
  }
  if (empty($time1) || empty($time2)) {
    return FALSE;
  }

  $tmp = DateHelper::seconds('s', TRUE, $increment);
  $max_seconds = intval(array_pop($tmp));
  $tmp = DateHelper::minutes('i', TRUE, $increment);
  $max_minutes = intval(array_pop($tmp));

  // See if minutes and seconds are the maximum allowed for an increment or the
  // maximum possible (59), or 0.
  switch ($granularity) {
    case 'second':
      $min_match = $time1 == '00:00:00'
        || ($hour1 == 0 && $min1 == 0 && $sec1 == 0);
      $max_match = $time2 == '00:00:00'
        || ($hour2 == 23 && in_array($min2, array($max_minutes, 59)) && in_array($sec2, array($max_seconds, 59)))
        || ($hour1 == 0 && $hour2 == 0 && $min1 == 0 && $min2 == 0 && $sec1 == 0 && $sec2 == 0);
      break;
    case 'minute':
      $min_match = $time1 == '00:00:00'
        || ($hour1 == 0 && $min1 == 0);
      $max_match = $time2 == '00:00:00'
        || ($hour2 == 23 && in_array($min2, array($max_minutes, 59)))
        || ($hour1 == 0 && $hour2 == 0 && $min1 == 0 && $min2 == 0);
      break;
    case 'hour':
      $min_match = $time1 == '00:00:00'
        || ($hour1 == 0);
      $max_match = $time2 == '00:00:00'
        || ($hour2 == 23)
        || ($hour1 == 0 && $hour2 == 0);
      break;
    default:
      $min_match = TRUE;
      $max_match = FALSE;
  }

  if ($min_match && $max_match) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Helper function to round minutes and seconds to requested value.
 */
function date_increment_round(&$date, $increment) {
  // Round minutes and seconds, if necessary.
  if (is_object($date) && $increment > 1) {
    $day = intval(date_format($date, 'j'));
    $hour = intval(date_format($date, 'H'));
    $second = intval(round(intval(date_format($date, 's')) / $increment) * $increment);
    $minute = intval(date_format($date, 'i'));
    if ($second == 60) {
      $minute += 1;
      $second = 0;
    }
    $minute = intval(round($minute / $increment) * $increment);
    if ($minute == 60) {
      $hour += 1;
      $minute = 0;
    }
    date_time_set($date, $hour, $minute, $second);
    if ($hour == 24) {
      $day += 1;
      $hour = 0;
      $year = date_format($date, 'Y');
      $month = date_format($date, 'n');
      date_date_set($date, $year, $month, $day);
    }
  }
  return $date;
}

/**
 * Determines if a date object is valid.
 *
 * @param object $date
 *   The date object to check.
 *
 * @return bool
 *   TRUE if the date is a valid date object, FALSE otherwise.
 */
function date_is_date($date) {
  if (empty($date) || !is_object($date) || !empty($date->errors)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * This function will replace ISO values that have the pattern 9999-00-00T00:00:00
 * with a pattern like 9999-01-01T00:00:00, to match the behavior of non-ISO
 * dates and ensure that date objects created from this value contain a valid month
 * and day. Without this fix, the ISO date '2020-00-00T00:00:00' would be created as
 * November 30, 2019 (the previous day in the previous month).
 *
 * @param string $iso_string
 *   An ISO string that needs to be made into a complete, valid date.
 *
 * @TODO Expand on this to work with all sorts of partial ISO dates.
 */
function date_make_iso_valid($iso_string) {
  // If this isn't a value that uses an ISO pattern, there is nothing to do.
  if (is_numeric($iso_string) || !preg_match(DATE_REGEX_ISO, $iso_string)) {
    return $iso_string;
  }
  // First see if month and day parts are '-00-00'.
  if (substr($iso_string, 4, 6) == '-00-00') {
    return preg_replace('/([\d]{4}-)(00-00)(T[\d]{2}:[\d]{2}:[\d]{2})/', '${1}01-01${3}', $iso_string);
  }
  // Then see if the day part is '-00'.
  elseif (substr($iso_string, 7, 3) == '-00') {
    return preg_replace('/([\d]{4}-[\d]{2}-)(00)(T[\d]{2}:[\d]{2}:[\d]{2})/', '${1}01${3}', $iso_string);
  }

  // Fall through, no changes required.
  return $iso_string;
}


/**
 * @file
 * SQL helper for Date API.
 *
 * @TODO
 * Add experimental support for sqlite: http://www.sqlite.org/lang_datefunc.html
 * and Oracle (http://psoug.org/reference/date_func.html and
 * http://psoug.org/reference/datatypes.html) date/time functions.
 */

/**
 * A helper function to do cross-database concatation of date parts.
 *
 * @param array $array
 *   An array of values to be concatonated in sql.
 *
 * @return string
 *   Correct sql string for database type.
 */
function date_sql_concat($array) {
  switch (db_driver()) {
    case 'mysql':
    case 'mysqli':
      return "CONCAT(" . implode(",", $array) . ")";
    case 'pgsql':
      return implode(" || ", $array);
  }
}

/**
 * Helper function to do cross-database NULL replacements
 *
 * @param array $array
 *   An array of values to test for NULL values.
 *
 * @return string
 *   SQL statement to return the first non-NULL value in the list.
 */
function date_sql_coalesce($array) {
  switch (db_driver()) {
    case 'mysql':
    case 'mysqli':
    case 'pgsql':
      return "COALESCE(" . implode(',', $array) . ")";
  }
}

/**
 * A helper function to do cross-database padding of date parts.
 *
 * @param string $str
 *   A string to apply padding to
 * @param int $size
 *   The size the final string should be
 * @param string $pad
 *   The value to pad the string with
 * @param string $side
 *   The side of the string to pad
 */
function date_sql_pad($str, $size = 2, $pad = '0', $side = 'l') {
  switch ($side) {
    case 'r':
      return "RPAD($str, $size, '$pad')";
    default:
      return "LPAD($str, $size, '$pad')";
  }
}
